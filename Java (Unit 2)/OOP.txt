==== Object-Oriented Programming ====

Person Class
```
public class Person {
 public String name;
 public int age;
 public String address;
}
```
- defines a simple data class representing a person

Main Class
```
public class Main {
 public static void main(String[] args) {
  
  Person alice = new Person();
  alice.name = "Alice";
  alice.age = 30;
  alice.address = "123 Main St."

  Person bob = new Person();
  bob.name = "Bob";
  bob.age = 40;
  bob.address = "456 Elm St."
 
 }
}
```
- the main class is our entry into the program
- here we can initialize new instances of our Person class
- however there are some problems
 - this is verbose
 - we could forget some variables
 - it is easier to make mistakes (redefining a value for alice instead of adding one for bob)
 - it is hard to change across an entire codebase if we add a new value like a gender string

Constructors
- a special method that is called when a new object is created
- it shares the class' name
- it has no return type
```
public class Person {
 public String name;
 public int age;
 public String address;

 //Constructor
 public Person(String name, int age, String address) {
  this.name = name;
  this.age = age;
  this.address = address;
 }
}
```
- ^ an example of our Person class from earlier
- does not return anything
- uses this.variableName to set values (like JavaScript)
- will be called with the new keyword.
```
Person alice = new Person("Alice", 30, "123 Main St.");
Person bob = new Person("Bob", 40, "456 Elm St.");

Creating Multiple Constructors
```
// inside "public class Person"
public Person() {

}
```
- If you want to still be able to create an object with no parameters ie `Person bob = new Person();`
- You will need to make a second constructor
- It will be set up like the first, but without parameters, and no internals.
````
Person bob = new Person("Bob", 40, "456 Elm St.");
Person charlie = new Person(); //also works now
```
- you can create as many constructors as you want, as long as they have a different set of parameters
- choose a constructor by using the set of parameters in the new Person() call.


# Protecting Fields with Getters and Setters

- in the person class, we have made the fields (name/age/address) `public`.
- a better practice is to make them `private`.
- use public "get" methods to access fields
- use public "set" methods to modify fields
- this is called **encapsulation**.
```
public class Person {
 private String name;
 
 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 }

}
```
Using the methods:
```
alice.setName("Alice Smith");
sout("Full Name: " alice.getName);
```
- an encapsulated data class is called a Data Class or a Plain Old Java Object
- POJO is not a formal construct, it is a common term to describe classes containing only
 - fields
 - constructors
 - getters & setters


# Adding Methods to the Person Class

Instance Methods
- are called on an instance of a class.
- do not have the `static` keyword.
- can access and modify the specific fields of that object
- getters & setters are instance methods
// static methods belong to the class itself, are called on the class, and dont have access to instance specific fields.

Private Methods
- can only be called from within the class
- good for helper functions



==== Creating more Flexible & Powerful Classes ====

# Method Overloading
- creating multiple methods of the same name
- each method needs a different assortment of parameters
- this allows methods to be used in different ways, depending on input
```
public int isAdult() { // default use of the method
 return this.age >= 18;
}
public boolean isAdult(int threshold) { // Allows age threshold to be defined.
 return this.age >= threshold;          // Useful if a site requires a user to be 21+ to buy alcohol.
}
```
- one of these returns a boolean while the other returns an int. Is this intended? I will test.


# Static Methods and Members

Static Methods
- called on the class itself
- cannot access non-static fields
`public static Person getOlderPerson(person1, person2) { /* code */ }`
...
`Person olderPerson = Person.getOlderPerson(person1, person2);`
- Note: Java objects are passed by reference.
 - it does not copy the object.
 - if you modify a passed object, it modifies the real thing.
- are also used for methods useful to a class, but don't require instanced data
 - for example, a method to return a random name.



==== Inheritance and Polymorphism in Java ====
- create classes that inherit properties (fields?) and methods from other classes.
- create a hierarchy of classes that share functionality
Polymorphism
- use a child class object wherever a parent class object is expected

Basic Inheritance
- let's create a more specific kind of person - a "Student"
- don't just copy the Person class and add fields, it is repetitive.
```
public class Student extends Person {
 public int studentId;
}
```
- extend Person and add relevant fields.
- Student recieves Person's fields and methods as well as its own.
- Student does not recieve private members (or does it and it just cannot access them?)
// does "member" just mean field or method?

Constructors and Inheritance
- when "Student" is constructed, it must use the Person constructor
- use the `super` keyword to do this.
```
public Student(String name, int age, int studentId) {
 super(name, age); // call the Person constructor.
 this.studentId = studentId; // fill in additional fields.
}
```
- what happens if you don't create a constructor? I assume it is just like when you don't create a constructor on a normal class, it leaves it all blank.

Private & Protected Members
- a derived class cannot access private members of its inherited class.
- a derived class inherits private members, but cannot access them.
- a `protected` member is accessible by derived classes too.
```
public class Person {
 plublic String name; // accessible anywhere.
 protected int age;
 private String address; // only accessible by 