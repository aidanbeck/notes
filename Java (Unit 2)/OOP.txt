==== Object-Oriented Programming ====

Person Class
```
public class Person {
 public String name;
 public int age;
 public String address;
}
```
- defines a simple data class representing a person

Main Class
```
public class Main {
 public static void main(String[] args) {
  
  Person alice = new Person();
  alice.name = "Alice";
  alice.age = 30;
  alice.address = "123 Main St."

  Person bob = new Person();
  bob.name = "Bob";
  bob.age = 40;
  bob.address = "456 Elm St."
 
 }
}
```
- the main class is our entry into the program
- here we can initialize new instances of our Person class
- however there are some problems
 - this is verbose
 - we could forget some variables
 - it is easier to make mistakes (redefining a value for alice instead of adding one for bob)
 - it is hard to change across an entire codebase if we add a new value like a gender string

Constructors
- a special method that is called when a new object is created
- it shares the class' name
- it has no return type
```
public class Person {
 public String name;
 public int age;
 public String address;

 //Constructor
 public Person(String name, int age, String address) {
  this.name = name;
  this.age = age;
  this.address = address;
 }
}
```
- ^ an example of our Person class from earlier
- does not return anything
- uses this.variableName to set values (like JavaScript)
- will be called with the new keyword.
```
Person alice = new Person("Alice", 30, "123 Main St.");
Person bob = new Person("Bob", 40, "456 Elm St.");

Creating Multiple Constructors
```
// inside "public class Person"
public Person() {

}
```
- If you want to still be able to create an object with no parameters ie `Person bob = new Person();`
- You will need to make a second constructor
- It will be set up like the first, but without parameters, and no internals.
````
Person bob = new Person("Bob", 40, "456 Elm St.");
Person charlie = new Person(); //also works now
```
- you can create as many constructors as you want, as long as they have a different set of parameters
- choose a constructor by using the set of parameters in the new Person() call.


# Protecting Fields with Getters and Setters

- in the person class, we have made the fields (name/age/address) `public`.
- a better practice is to make them `private`.
- use public "get" methods to access fields
- use public "set" methods to modify fields
- this is called **encapsulation**.
```
public class Person {
 private String name;
 
 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 }

}
```
Using the methods:
```
alice.setName("Alice Smith");
sout("Full Name: " alice.getName);
```
- an encapsulated data class is called a Data Class or a Plain Old Java Object
- POJO is not a formal construct, it is a common term to describe classes containing only
 - fields
 - constructors
 - getters & setters


# Adding Methods to the Person Class

Instance Methods
- are called on an instance of a class.
- do not have the `static` keyword.
- can access and modify the specific fields of that object
- getters & setters are instance methods
// static methods belong to the class itself, are called on the class, and dont have access to instance specific fields.

Private Methods
- can only be called from within the class
- good for helper functions



==== Creating more Flexible & Powerful Classes ====

# Method Overloading
- creating multiple methods of the same name
- each method needs a different assortment of parameters
- this allows methods to be used in different ways, depending on input
```
public int isAdult() { // default use of the method
 return this.age >= 18;
}
public boolean isAdult(int threshold) { // Allows age threshold to be defined.
 return this.age >= threshold;          // Useful if a site requires a user to be 21+ to buy alcohol.
}
```
- one of these returns a boolean while the other returns an int. Is this intended? I will test.


# Static Methods and Members

Static Methods
- called on the class itself
- cannot access non-static fields
`public static Person getOlderPerson(person1, person2) { /* code */ }`
...
`Person olderPerson = Person.getOlderPerson(person1, person2);`
- Note: Java objects are passed by reference.
 - it does not copy the object.
 - if you modify a passed object, it modifies the real thing.
- are also used for methods useful to a class, but don't require instanced data
 - for example, a method to return a random name.



==== Inheritance and Polymorphism in Java ====

Inheritance
- create classes that inherit properties (fields?) and methods from other classes.
- create a hierarchy of classes that share functionality
Polymorphism
- use a child class object wherever a parent class object is expected

Basic Inheritance
- let's create a more specific kind of person - a "Student"
- don't just copy the Person class and add fields, it is repetitive.
```
public class Student extends Person {
 public int studentId;
}
```
- extend Person and add relevant fields.
- Student recieves Person's fields and methods as well as its own.
- Student does not recieve private members (or does it and it just cannot access them?)
// does "member" just mean field or method?

Constructors and Inheritance
- when "Student" is constructed, it must use the Person constructor
- use the `super` keyword to do this.
```
public Student(String name, int age, int studentId) {
 super(name, age); // call the Person constructor.
 this.studentId = studentId; // fill in additional fields.
}
```
- `super` calls the parent's constructor and applies it to its own instance.
- then, the extention can declare its specific methods.
- what is the vocab term for an extention? is it a child? //I think it is a "derived class"
- what happens if you don't create a constructor? I assume it is just like when you don't create a constructor on a normal class, it leaves it all blank.

Private & Protected Members
- a derived class cannot access private members of its inherited class.
- a derived class inherits private members, but cannot access them.
- a `protected` member is accessible by derived classes too.
```
public class Person {
 plublic String name; // accessible anywhere.
 private String address; // accessible only by its native class.
 protected int age; // accessible by its native class AND classes derived from that native class.
}
```
// in the lesson, a parent class is called a "base" class, and a child/extended class is called a "derived" class.

Method Overriding
- method *overloading* was previously covered for creating method variants that change depending on input type
- method *overriding* can replace base methods in a derived class.
```
public class Person {
 public void greet() {
  sout("Hello, " + name);
 }
}

public class Teacher extends Person {
 public void greet() {
  sout("Good morning, " + name);
 }
}
```
- `greet()` overrides its base varient within the teacher class
- over*loading* adds a variant, over*riding* replaces.


# Polymorphism
- "treat objects of derived classes as objects of their base class"
- what does it mean to "treat" them?

```
Person  person  = new Person("Alice");
Student student = new Student("Bob", 12345); // Student extends Person
Teacher teacher = new Teacher("Charlie", 67890); // Teacher extends Person
```
- all three of these are instances of the Person class
- even though `student` and `teacher` are also instances of their own class
```
List<Person> people = new ArrayList<>();
people.add(person);
people.add(student);
people.add(teacher);
```
- they all can be added to a Person ArrayList, even if they are a derived class
- because their bas class is person, they can be treated as a person.
- they still retain any member modifications made in their derived class
```
public static void displayPerson(Person p) { ... }

// all work, despite being more specific types
displayPerson(person);
displayPerson(student);
displayPerson(teacher);
```
- you can also pass derived class objects to functions expecting a base class type
- this is another way they are "treated" as their base class.

The Parent of All Classes
- every class has a parent class, whether we define one or not.
- the `Object` class is automatically assigned to classes without a base.
- this means you can use `Object` to treat all classes.
```
List<Object> stuff - new ArrayList<>(); // can contain ANY object
public void printObject(Object input) { ... } // can recieve ANY object
```

# Class Hierarchies
class hierarchy:
- a set of classes that are related by inheritance
- models certain domain / set of relationships
```
Person
  - Employee
    - Manager
    - SalesPerson
  - Customer
```
- an example of a class hierarchy