==== An Introduction to SQL ====

// MySQL is the database type, SQL is the language to manipulate it.
// Fact check this, since this is my assumption.

Creating a Schema
- Open the "Schemas" tab. Tabs are at the bottom of the "Navigator" panel.
- Right click. Select "Create Schema"
- Name it and click "Apply". (like we did in the last lesson)
- This is our database, it will hold our tables.

Creating a Table
- Expand your schema in the navigator.
- Right click on "Tables", select "Create Table".
- Name the table, for example "users".
Creating Columns
- For now we will create columns using the UI
- Each column has a:
 - name
 - data type
 - attribute flags

Query Editor
- `Query > New Tab to Current Server`
- here we can write SQL
- Notice the important buttons
 - Execute (lightning bolt) - runs query
 - Save (floppy disk) - saves query to file
 - Open (folder) - open query from file

Insert New Data
```
INSERT INTO users (username, firstName, lastName, age)
VALUES ('jdoe', 'John', 'Doe', 35);
```
- `INSERT` - Add new row to the table.
- `INTO` - define table to add to. In this case `users`.
- `( ... )` - the column names you want to affect.
- `VALUES ( ... );` - the values "inserted" into those columns.

- This is the traditional syntax, but it could also be on one line and with lowercase letters.
- Modern syntax is moving towards lowercase characters.
- you may also need to select the database with `USE db_name;`
- We did not include the id column.
 - the id column is auto-incrementing based on our attribute flags.
 - MySQL will automatically assign unique values for each added row.

Insert Multiple rows
```
INSERT INTO users (username, firstName, lastName, age)
VALUES
 ('asmith', 'Alice', 'Smith', 20),
 ('bdoe', 'Bob', 'Doe', 33),
 ('cjohnson', 'Charlie', 'Johnson', 41);
```
- separate value groups with commas

Disabling Safe Mode
- before we can update/delete rows, we need to disable safe mode.
- `SET SQL_SAFE_UPDATES = 0;` can fix this.
- You can also change your MySQL configuration.

Updating Data
```
UPDATE users SET firstName = 'Jane', lastname = 'Doe'
WHERE username = 'jdoe';
```
- `UPDATE users` define the table to update.
- `SET column = value` define new values for columns.
- `WHERE column = value` apply this to all rows with this row/value pair.
 - if ommitted, SQL will update all rows.

Deleting Data
`DELETE FROM users WHERE username = 'jdoe';`
- `DELETE FROM users` - define the table.
- `WHERE username = 'jdoe';` - define condition for deleted rows.

Select Queries
`SELECT * FROM users;`
- retrieve all rows
- using * gets all columns
`SELECT firstName, lastName FROM users WHERE lastName = 'Doe';`
- `SELECT columnA, columnB` - define columns to get data from
- `FROM users` - define table to get data from.
- `WHERE column = value` - condition to get intended rows.

Compound Conditions
`SELECT * FROM users WHERE lastName = 'Doe' AND NOT firstName = 'John';`
- use `AND` and `OR` to make complex conditions
- like `&&` and `||` in other languages.
- use `NOT` like a bang operator `!`.
Operators Replacing `=`
 - `=` equal to
 - `!=` not equal to
 - `>`, `<` greater/less than
 - `>=`, '<=` greater/less than or equal to
 - `LIKE` Matches a string(?) pattern with `%` as a wildcard for any number of characters
 - `IN (value1, value2...)` equal to any of these values

Aliases
`SELECT firstName AS First, lastName AS Last FROM users;`
- change the name of a variable (column) not on the db, but within our result set.

Calculated Fields
`SELECT username, age + 10 AS ageIn10Years FROM users;`
- the result set can modify values from the column with a formula.
- here, we add 10 to the value from the age column for our results.
- this only changes our results, not the data table.
- we also use `AS` to alter the alias accordingly.
`SELECT concat(firstName, ' ', lastName) AS fullName FROM users;`
- the functions allow us to pull data in more configurations
- `concat()` allows us to merge multiple string column values together into our output
Common SELECT Functions
- `concat(string1, ' ', string2)` combine strings
- `length(string)` return length of string
- `upper(string)` return string in uppercase
- `lower(string)` return string in lowercase
- `substring(string, index, length)` return "slice" of string
- `trim(string)` return string with outer whitespace removed
- `round(int, x)` returns integer rounded to x decimal places

Sorting with ORDER BY
`SELECT * FROM users ORDER BY age DESC;`
- `ORDER BY age` selects the column to order by.
- `DESC` to sort in a descending order.
SELECT * FROM users ORDER BY lastName ASC, firstName ASC;
- the first clauses is sorted by
- the second clause is used to sort any rows where the first clause matches
- `ASC` to sort in an ascending order.

Limiting the Number of Rows Returned
`SELECT * FROM users LIMIT 5;`
- return only the first 5 rows
`SELECT * FROM users LIMIT 5 OFFSET 5;`
- `OFFSET` skips the first 5 rowS
- `LIMIT` gets the 5 rows after the offset

Paging with LIMIT, OFFSET, and ORDER BY
`SELECT * FROM users ORDER BY lastName ASC LIMIT 10 OFFSET 20;`
- get the third page, each page has 10 users.
- values in reality would change depending on page, ie OFFSET page*10-10



==== SQL In Depth ====

Example DB Tables
Customers
 - id int
 - first_name
 - last_name
Orders
 - id int
 - customer_id
 - order_date
 - total_amount

GROUP BY and Aggregate Functions
- `GROUP BY` is usable in `SELECT` statements.
- groups rows with similarities into "summary rows"???
```
SELECT customer_id, SUM(total_amount) AS total_spent
FROM orders
GROUP BY customer_id;
```
- gets all `customer_id` & `total_amount` values from orders
- groups orders by `customer_id`
- condenses each group into a `customer_id` and the sum of that group's `total_spent`s.
- this is a little confusing to read in its written order, but it lets you get each customer's total spending.
- the lesson also uses "roll up" in place of "group by". It "rolls" all the rows up into one.
- it uses SUM() to roll the group up. `SUM()` cannot be used without `GROUP BY`
- all columns in the SELECT statement with a GROUP BY clause must have an "aggregate function" ???
 - the database must be able to combine each group
Exception to above^
```
SELECT customer_id, order_date, SUM(total_amount) AS total_spent
FROM orders
GROUP BY customer_id, order_date;
```
- because order_date is added to the GROUP_BY clause, it creates more specific groups

HAVING and WHERE Clauses
```
SELECT customer_id, SUM(total_amount) AS total_spent
FROM orders
WHERE total_amount >= 1.00 -- don't add orders less than $1 into total
GROUP BY customer_id
HAVING SUM(total_amount) > 200; -- only return totals greater than $200
```
- `WHERE` is used to filter rows before `GROUP BY`/aggregation is applied.
- the `HAVING` clause filters rows *after* aggregation.


# Joins
- used to extend the results of a table query
- includes data from another table
 - other table is related via a common field value

INNER JOINs
- say we want to get customer names on their orders
- but customers and orders are stored separately
- other than their common field, the `customer_id`
```
SELECT orders.id, customers.first_name, customers.last_name, orders.order_date, orders.total_amount
FROM orders
INNER JOIN customers ON orders.customer_id = customers.id;
```
- this "joins" customers rows to orders rows, where the id's match
- excludes rows that don't have a match (for example, the order with a NULL customer_id is omitted, even though it's in the original table)

LEFT JOINs
- similar to an `INNER JOIN`, but...
- it inclues all rows from the first table even if they don't have a matching value with the other table
- if `customer_id` is NULL for an order, `firstName` & `lastName` will simply also be NULL
SELECT orders.id, customers.first_name, customers.last_name, orders.order_date, orders.total_amount
FROM orders
LEFT JOIN customers ON orders.customer_id = customers.id;
```
- use LEFT JOIN when you want to include all rows in first table, even if there are no matching rows in the second table

Other Types of JOINs
- uncommon, but you should be aware of them
- `RIGHT JOIN` includes all rows from the second table, even without matching rows
- `FULL JOIN` includes all rows from both tables, regardless of matches
- `CROSS` "returns the Cartesian product of the tables", rarely used


# SubQueries
- input query results into another query

Scalar Subqueries
- return as single value
- can be used within conditions
```
-- the scalar subquery calculates the average total_amount
-- the main query then uses that to only return rows with above average total_amount
SELECT id, order_date, total_amount
FROM orders
WHERE total_amount >= (SELECT AVG(total_amount) FROM orders); 
```

Column Subqueries
- return multiple values (multiple rows with a single column)
- usable anywhere you'd use a list of values
- useable in an `IN` clause
```
-- the column subquery gets a list of id's for customers with the last name "Smith"
-- the main query uses that list to print out all orders with those id's
SELECT id, order_date, total_amount, customer_id
FROM orders
WHERE customer_id IN (SELECT id FROM customers WHERE last_name = 'Smith');
```

Table Subqueries
- return multiple columns & rows
- usable anywhere you would use a table
- usable in a `FROM` clause
```
-- the table subquery gets rows with three columns from orders
-- the main subquery gets the order_date's from those rows
SELECT order_date
FROM (SELECT id, order_date, total_amount FROM orders) AS order_summary;
```

Summary:
- Scalar Subqueries: return a single value (one row with one column)
- Column Subqueries: return a list of values (multiples rows with one column)
- Table  Subqueries: return a table (multiple rows with multiple columns)
